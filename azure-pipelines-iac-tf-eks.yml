# Azure DevOps Pipeline for Terraform EKS Infrastructure and Flask App Deployment
# This pipeline provisions EKS infrastructure using Terraform and deploys a Flask application

trigger:
- main

variables:
  # Build variables
  awsECRServiceConnection: 'aws-ecr-connection'
  imageRepository: 'flask-static-app'
  ecrRegistry: '578478003474.dkr.ecr.us-east-1.amazonaws.com' # Your actual ECR URI
  dockerfilePath: 'src/Dockerfile'
  tag: '$(Build.BuildId)'
  imagePullPolicy: 'Always'
  
  # Terraform variables
  terraformVersion: 'latest'
  awsServiceConnection: 'service_connect_aws_tf'
  awsRegion: 'us-east-1'
  
  # Kubernetes variables
  kubernetesServiceConnection: 'KubernetesServiceConnection'
  namespace: 'default'

stages:
- stage: Infrastructure
  displayName: 'Provision EKS Infrastructure'
  jobs:
  - job: TerraformDeploy
    displayName: 'Deploy EKS Cluster with Terraform'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Terraform Init'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
        
    - task: TerraformTask@5
      displayName: 'Terraform Plan'
      inputs:
        provider: 'aws'
        command: 'plan'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - task: TerraformTask@5
      displayName: 'Terraform Apply'
      inputs:
        provider: 'aws'
        command: 'apply'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - script: |
        # Get cluster name from Terraform output
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        echo "##vso[task.setvariable variable=EKS_CLUSTER_NAME;isOutput=true]$CLUSTER_NAME"
        echo "EKS Cluster Name: $CLUSTER_NAME"
      displayName: 'Get Cluster Name from Terraform'
      name: getClusterName
        
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(getClusterName.EKS_CLUSTER_NAME)'
        
    - task: AWSCLI@1
      displayName: 'Setup AWS Environment for ECR'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'sts'
        awsSubCommand: 'get-caller-identity'
        
    - script: |
        echo "=== Setting up ECR Repository: $(imageRepository) ==="
        
        # Check if repository exists
        if aws ecr describe-repositories --repository-names $(imageRepository) --region $(awsRegion) 2>/dev/null; then
          echo "✅ ECR repository '$(imageRepository)' already exists"
        else
          echo "📦 Creating ECR repository '$(imageRepository)'..."
          aws ecr create-repository \
            --repository-name $(imageRepository) \
            --region $(awsRegion) \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
          echo "✅ ECR repository '$(imageRepository)' created successfully"
        fi
        
        # Set lifecycle policy to manage image retention
        echo "🔄 Setting lifecycle policy..."
        aws ecr put-lifecycle-policy \
          --repository-name $(imageRepository) \
          --region $(awsRegion) \
          --lifecycle-policy-text '{
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }' || echo "⚠️ Lifecycle policy already exists or failed to set"
        
        # Get and display repository URI
        REPO_URI=$(aws ecr describe-repositories \
          --repository-names $(imageRepository) \
          --region $(awsRegion) \
          --query 'repositories[0].repositoryUri' \
          --output text)
        
        echo "📍 ECR Repository URI: $REPO_URI"
        echo "##vso[task.setvariable variable=ECR_REPOSITORY_URI]$REPO_URI"
        
        # Verify the URI matches our expected format
        EXPECTED_URI="$(ecrRegistry)/$(imageRepository)"
        if [ "$REPO_URI" = "$EXPECTED_URI" ]; then
          echo "✅ Repository URI matches expected format"
        else
          echo "⚠️ Warning: Repository URI ($REPO_URI) differs from expected ($EXPECTED_URI)"
        fi
        
      displayName: 'Setup ECR Repository'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)

- stage: Build
  displayName: 'Build and Push Docker Image'
  dependsOn: Infrastructure
  condition: succeeded()
  jobs:
  - job: BuildImage
    displayName: 'Build Flask Application'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: AWSCLI@1
      displayName: 'Setup AWS Environment for Build'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'sts'
        awsSubCommand: 'get-caller-identity'
      
    - script: |
        # ECR Login, Build and Push combined
        echo "=== Logging into ECR ==="
        aws ecr get-login-password --region $(awsRegion) | docker login --username AWS --password-stdin $(ecrRegistry)
        
        echo "=== Building Docker image ==="
        docker build -t $(ecrRegistry)/$(imageRepository):$(tag) -t $(ecrRegistry)/$(imageRepository):latest -f $(dockerfilePath) src/
        
        echo "=== Pushing to ECR ==="
        docker push $(ecrRegistry)/$(imageRepository):$(tag)
        docker push $(ecrRegistry)/$(imageRepository):latest
        
        echo "Successfully built and pushed: $(ecrRegistry)/$(imageRepository):$(tag)"
        
        # Verify the image was pushed successfully
        echo "=== Verifying images in ECR ==="
        aws ecr list-images --repository-name $(imageRepository) --region $(awsRegion)
        
      displayName: 'ECR Login, Build and Push Docker Image'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)

- stage: Deploy
  displayName: 'Deploy to EKS'
  dependsOn: 
  - Infrastructure
  - Build
  condition: succeeded()
  jobs:
  - job: DeployToEKS
    displayName: 'Deploy Flask App to EKS'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Initialize Terraform with AWS Credentials'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
      
    - script: |
        echo "Debug: EKS_CLUSTER_NAME variable value: '$(EKS_CLUSTER_NAME)'"
        
        # Get cluster name from Terraform output
        CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "")
        
        if [ -z "$CLUSTER_NAME" ]; then
          echo "Warning: Could not get cluster name from Terraform output"
          echo "Listing all EKS clusters to find the correct one..."
          aws eks list-clusters --region $(awsRegion)
          CLUSTER_NAME=$(aws eks list-clusters --region $(awsRegion) --query 'clusters[0]' --output text)
          echo "Using first available cluster: $CLUSTER_NAME"
        fi
        
        if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" = "None" ]; then
          echo "Error: No EKS clusters found!"
          exit 1
        fi
        
        echo "Retrieved cluster name: $CLUSTER_NAME"
        echo "##vso[task.setvariable variable=CLUSTER_NAME]$CLUSTER_NAME"
        
      displayName: 'Get Cluster Name from Terraform'
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(awsRegion)
        
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig with Dynamic Cluster Name'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(CLUSTER_NAME)'
        
    - task: Kubernetes@1
      displayName: 'Verify Kubernetes Connectivity'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'nodes'
        
    - task: AWSCLI@1
      displayName: 'Get ECR Login Token'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'get-login-password'
        awsArguments: '--region $(awsRegion)'
      
    - script: |
        # Create ECR registry secret using current kubeconfig context
        echo "Creating ECR registry secret..."
        TOKEN=$(aws ecr get-login-password --region $(awsRegion))
        
        # Use the kubeconfig context that was set up by the kubernetesServiceConnection
        kubectl create secret docker-registry ecr-registry-secret \
          --namespace=default \
          --docker-server=$(ecrRegistry) \
          --docker-username=AWS \
          --docker-password=$TOKEN \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo "ECR registry secret created successfully"
      displayName: 'Create ECR Registry Secret'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)
        
    - task: Kubernetes@1
      displayName: 'Patch Service Account with Image Pull Secret'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'patch'
        arguments: 'serviceaccount deploy-robot -p "{\"imagePullSecrets\": [{\"name\": \"ecr-registry-secret\"}]}" --type=merge'
        
    - script: |
        # Replace image tag in deployment manifest
        sed -i "s|#{DOCKER_IMAGE_TAG}#|$(ecrRegistry)/$(imageRepository):$(tag)|g" manifests/deployment.yaml
        echo "Updated deployment manifest with image: $(ecrRegistry)/$(imageRepository):$(tag)"
      displayName: 'Update deployment manifest with ECR image'
      
    - task: Kubernetes@1
      displayName: 'Apply Service Account for ECR'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/serviceaccount-ecr.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply ConfigMap'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/configmap.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Service'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/service.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Deployment'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/deployment.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Pod Disruption Budget'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/pdb.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Horizontal Pod Autoscaler'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/hpa.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Ingress'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/ingress.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Wait for Deployment Rollout'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'rollout'
        arguments: 'status deployment/flask-app-deployment --timeout=300s'
        
    - task: Kubernetes@1
      displayName: 'Get Application Status'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'pods,svc,ingress -l app=flask-app'
        
    - task: Kubernetes@1
      displayName: 'Get Ingress URL'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'ingress flask-app-ingress -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"'