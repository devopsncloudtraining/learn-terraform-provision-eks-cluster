# Azure DevOps Pipeline for Terraform EKS Infrastructure and Flask App Deployment
# This pipeline provisions EKS infrastructure using Terraform and deploys a Flask application

trigger:
- main

variables:
  # Build variables
  awsECRServiceConnection: 'aws-ecr-connection'
  imageRepository: 'flask-static-app'
  ecrRegistry: '112779685052.dkr.ecr.us-east-1.amazonaws.com' # Your actual ECR URI
  dockerfilePath: 'src/Dockerfile'
  tag: '$(Build.BuildId)'
  imagePullPolicy: 'Always'
  
  # Terraform variables
  terraformVersion: 'latest'
  awsServiceConnection: 'service_connect_aws_tf'
  awsRegion: 'us-east-1'
  
  # Kubernetes variables
  kubernetesServiceConnection: 'KubernetesServiceConnection'
  namespace: 'default'

stages:
- stage: Infrastructure
  displayName: 'Provision EKS Infrastructure'
  jobs:
  - job: TerraformDeploy
    displayName: 'Deploy EKS Cluster with Terraform'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Terraform Init'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
        
    - task: TerraformTask@5
      displayName: 'Terraform Plan'
      inputs:
        provider: 'aws'
        command: 'plan'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - task: TerraformTask@5
      displayName: 'Terraform Apply'
      inputs:
        provider: 'aws'
        command: 'apply'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - script: |
            - task: TerraformInstaller@1
      displayName: 'Install Terraform for Deploy Stage'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Terraform Init for Cluster Name'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
        
    - script: |
        # Get cluster name from Terraform output
        echo "=== Getting cluster name from Terraform output ==="
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        
        if [ -n "$CLUSTER_NAME" ]; then
          echo "Found cluster name: $CLUSTER_NAME"
          echo "##vso[task.setvariable variable=EKS_CLUSTER_NAME]$CLUSTER_NAME"
        else
          echo "ERROR: Could not get cluster name from Terraform output"
          exit 1
        fi
      displayName: 'Get Cluster Name from Terraform'
      
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(EKS_CLUSTER_NAME)'
        
    - script: |
        echo "Testing cluster connectivity..."
        kubectl cluster-info || echo "Warning: Cluster info failed"
        kubectl get nodes --timeout=30s || echo "Warning: Cannot get nodes yet"
      displayName: 'Test Kubernetes Connectivity'

- stage: Build
  displayName: 'Build and Push Docker Image'
  dependsOn: Infrastructure
  condition: succeeded()
  jobs:
  - job: BuildImage
    displayName: 'Build Flask Application'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: AWSCLI@1
      displayName: 'Get ECR Login Token'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'get-login-password'
        awsArguments: '--region $(awsRegion)'
        
    - script: |
        # Get ECR login token and login to Docker
        ECR_TOKEN=$(aws ecr get-login-password --region $(awsRegion))
        echo $ECR_TOKEN | docker login --username AWS --password-stdin $(ecrRegistry)
        echo "Successfully logged into ECR: $(ecrRegistry)"
        
        # Build the Docker image
        docker build -t $(ecrRegistry)/$(imageRepository):$(tag) -t $(ecrRegistry)/$(imageRepository):latest src/
        
        # Push both tags
        docker push $(ecrRegistry)/$(imageRepository):$(tag)
        docker push $(ecrRegistry)/$(imageRepository):latest
        
        echo "Successfully pushed images to ECR"
      displayName: 'Login, Build and Push to ECR'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)

- stage: Deploy
  displayName: 'Deploy to EKS'
  dependsOn: 
  - Infrastructure
  - Build
  condition: succeeded()
  jobs:
  - job: DeployToEKS
    displayName: 'Deploy Flask App to EKS'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Initialize Terraform with AWS Credentials'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
      
    - script: |
        echo "Debug: EKS_CLUSTER_NAME variable value: '$(EKS_CLUSTER_NAME)'"
        
        # Get cluster name from Terraform output
        CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "")
        
        if [ -z "$CLUSTER_NAME" ]; then
          echo "Warning: Could not get cluster name from Terraform output"
          echo "Listing all EKS clusters to find the correct one..."
          aws eks list-clusters --region $(awsRegion)
          CLUSTER_NAME=$(aws eks list-clusters --region $(awsRegion) --query 'clusters[0]' --output text)
          echo "Using first available cluster: $CLUSTER_NAME"
        fi
        
        if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" = "None" ]; then
          echo "Error: No EKS clusters found!"
          exit 1
        fi
        
        echo "Retrieved cluster name: $CLUSTER_NAME"
        echo "##vso[task.setvariable variable=CLUSTER_NAME]$CLUSTER_NAME"
        
      displayName: 'Get Cluster Name from Terraform'
        
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig with Dynamic Cluster Name'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(CLUSTER_NAME)'
        
    - script: |
        # Verify connectivity
        echo "Testing kubectl connectivity..."
        kubectl cluster-info
        echo "Getting cluster nodes..."
        kubectl get nodes --timeout=30s || echo "Warning: Could not get nodes, but continuing..."
      displayName: 'Verify Kubernetes Connectivity'
        
    - task: AWSCLI@1
      displayName: 'Setup ECR Secret for Kubernetes'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'get-login-password'
        awsArguments: '--region $(awsRegion)'
      env:
        AWS_ACCOUNT_ID: '112779685052' # Your actual AWS Account ID
        
    - script: |
        # Create ECR registry secret
        TOKEN=$(aws ecr get-login-password --region $(awsRegion))
        kubectl create secret docker-registry ecr-registry-secret \
          --namespace=default \
          --docker-server=$(ecrRegistry) \
          --docker-username=AWS \
          --docker-password=$TOKEN \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Update service account to use the secret
        kubectl patch serviceaccount deploy-robot \
          -p '{"imagePullSecrets": [{"name": "ecr-registry-secret"}]}' \
          --namespace=default || echo "Service account patch skipped"
      displayName: 'Create ECR Registry Secret'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)
        
    - script: |
        # Replace image tag in deployment manifest
        sed -i "s|#{DOCKER_IMAGE_TAG}#|$(ecrRegistry)/$(imageRepository):$(tag)|g" manifests/deployment.yaml
        echo "Updated deployment manifest with image: $(ecrRegistry)/$(imageRepository):$(tag)"
      displayName: 'Update deployment manifest with ECR image'
      
    - task: Kubernetes@1
      displayName: 'Apply Service Account for ECR'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/serviceaccount-ecr.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply ConfigMap'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/configmap.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Service'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/service.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Deployment'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/deployment.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Pod Disruption Budget'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/pdb.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Horizontal Pod Autoscaler'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/hpa.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Ingress'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/ingress.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Wait for Deployment Rollout'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'rollout'
        arguments: 'status deployment/flask-app-deployment --timeout=300s'
        
    - task: Kubernetes@1
      displayName: 'Get Application Status'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'pods,svc,ingress -l app=flask-app'
        
    - task: Kubernetes@1
      displayName: 'Get Ingress URL'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'ingress flask-app-ingress -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"'