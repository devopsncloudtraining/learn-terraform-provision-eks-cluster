# Azure DevOps Pipeline for Terraform EKS Infrastructure and Flask App Deployment
# This pipeline provisions EKS infrastructure using Terraform and deploys a Flask application

trigger:
- main

variables:
  # Build variables
  awsECRServiceConnection: 'aws-ecr-connection'
  imageRepository: 'flask_static_app'
  ecrRegistry: '905418462597.dkr.ecr.us-east-1.amazonaws.com' # Your actual ECR URI
  dockerfilePath: 'src/Dockerfile'
  tag: '$(Build.BuildId)'
  imagePullPolicy: 'Always'
  
  # Terraform variables
  terraformVersion: 'latest'
  awsServiceConnection: 'service_connect_aws_tf'
  awsRegion: 'us-east-1'
  
  # Kubernetes variables
  kubernetesServiceConnection: 'KubernetesServiceConnection'
  namespace: 'default'

stages:
- stage: Infrastructure
  displayName: 'Provision EKS Infrastructure'
  jobs:
  - job: TerraformDeploy
    displayName: 'Deploy EKS Cluster with Terraform'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Terraform Init'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
        
    - task: TerraformTask@5
      displayName: 'Terraform Plan'
      inputs:
        provider: 'aws'
        command: 'plan'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - task: TerraformTask@5
      displayName: 'Terraform Apply'
      inputs:
        provider: 'aws'
        command: 'apply'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - script: |
        # Get cluster name from Terraform output
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        echo "##vso[task.setvariable variable=EKS_CLUSTER_NAME;isOutput=true]$CLUSTER_NAME"
        echo "EKS Cluster Name: $CLUSTER_NAME"
      displayName: 'Get Cluster Name from Terraform'
      name: getClusterName
        
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(getClusterName.EKS_CLUSTER_NAME)'
        
    - task: AWSCLI@1
      displayName: 'Check if ECR Repository exists'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'describe-repositories'
        awsArguments: '--repository-names $(imageRepository)'
      continueOnError: true
        
    - task: AWSCLI@1
      displayName: 'Create ECR Repository if not exists'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'create-repository'
        awsArguments: '--repository-name $(imageRepository) --image-scanning-configuration scanOnPush=true --encryption-configuration encryptionType=AES256'
      continueOnError: true
      
    - task: AWSCLI@1
      displayName: 'Set ECR Lifecycle Policy'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'put-lifecycle-policy'
        awsArguments: '--repository-name $(imageRepository) --lifecycle-policy-text "{\"rules\":[{\"rulePriority\":1,\"description\":\"Keep last 10 images\",\"selection\":{\"tagStatus\":\"any\",\"countType\":\"imageCountMoreThan\",\"countNumber\":10},\"action\":{\"type\":\"expire\"}}]}"'
      continueOnError: true
      
    - task: AWSCLI@1
      displayName: 'Verify ECR Repository'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'describe-repositories'
        awsArguments: '--repository-names $(imageRepository) --query "repositories[0].repositoryUri" --output text'

- stage: Build
  displayName: 'Build and Push Docker Image'
  dependsOn: Infrastructure
  condition: succeeded()
  jobs:
  - job: BuildImage
    displayName: 'Build Flask Application'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: AWSCLI@1
      displayName: 'Verify AWS Connection'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'sts'
        awsSubCommand: 'get-caller-identity'
    
    - script: |
        echo "=== Debugging Build Configuration ==="
        echo "AWS Region: $(awsRegion)"
        echo "ECR Registry: $(ecrRegistry)"
        echo "Image Repository: $(imageRepository)"
        echo "Build Tag: $(tag)"
        echo "Dockerfile Path: $(dockerfilePath)"
        
        echo "=== Verifying Dockerfile exists ==="
        if [ -f "$(dockerfilePath)" ]; then
          echo "✅ Dockerfile found at $(dockerfilePath)"
          echo "First 10 lines of Dockerfile:"
          head -10 $(dockerfilePath)
        else
          echo "❌ Dockerfile not found at $(dockerfilePath)"
          echo "Current directory contents:"
          ls -la
          echo "src/ directory contents:"
          ls -la src/ || echo "src/ directory not found"
          exit 1
        fi
        
        echo "=== Building Docker image locally ==="
        docker build -t temp-flask-app:$(tag) -f $(dockerfilePath) src/
        if [ $? -eq 0 ]; then
          echo "✅ Docker build successful"
          echo "Built image:"
          docker images | grep temp-flask-app
        else
          echo "❌ Docker build failed"
          exit 1
        fi
        
        echo "=== Tagging for ECR ==="
        docker tag temp-flask-app:$(tag) $(ecrRegistry)/$(imageRepository):$(tag)
        docker tag temp-flask-app:$(tag) $(ecrRegistry)/$(imageRepository):latest
        
        echo "Tagged images:"
        docker images | grep $(imageRepository)
        
      displayName: 'Build Docker Image'
    
    - task: AWSShellScript@1
      displayName: 'Build and Push Docker Image to ECR'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        scriptType: 'inline'
        inlineScript: |
          set -euo pipefail

          echo "=== Build Configuration ==="
          echo "AWS Region: $(awsRegion)"
          echo "ECR Registry: $(ecrRegistry)"
          echo "Image Repository: $(imageRepository)"
          echo "Build Tag: $(tag)"
          echo "Dockerfile Path: $(dockerfilePath)"

          echo "=== Verifying Dockerfile exists ==="
          if [ -f "$(dockerfilePath)" ]; then
            echo "✅ Dockerfile found at $(dockerfilePath)"
          else
            echo "❌ Dockerfile not found at $(dockerfilePath)"
            ls -la src/
            exit 1
          fi

          echo "=== Building Docker image ==="
          docker build -t $(imageRepository):$(tag) -t $(imageRepository):latest -f $(dockerfilePath) src/

          echo "=== Authenticating to ECR ==="
          aws ecr get-login-password --region $(awsRegion) | docker login --username AWS --password-stdin $(ecrRegistry)

          echo "=== Tagging images for ECR ==="
          docker tag $(imageRepository):$(tag) $(ecrRegistry)/$(imageRepository):$(tag)
          docker tag $(imageRepository):latest $(ecrRegistry)/$(imageRepository):latest

          echo "=== Pushing images to ECR ==="
          docker push $(ecrRegistry)/$(imageRepository):$(tag)
          docker push $(ecrRegistry)/$(imageRepository):latest

          echo "🎉 Successfully built and pushed images to ECR"
      
    - task: AWSCLI@1
      displayName: 'Verify Images in ECR'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'list-images'
        awsArguments: '--repository-name $(imageRepository)'

- stage: Deploy
  displayName: 'Deploy to EKS'
  dependsOn: 
  - Infrastructure
  - Build
  condition: succeeded()
  jobs:
  - job: DeployToEKS
    displayName: 'Deploy Flask App to EKS'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Initialize Terraform with AWS Credentials'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
      
    - script: |
        echo "Debug: EKS_CLUSTER_NAME variable value: '$(EKS_CLUSTER_NAME)'"
        
        # Get cluster name from Terraform output
        CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "")
        
        if [ -z "$CLUSTER_NAME" ]; then
          echo "Warning: Could not get cluster name from Terraform output"
          echo "Listing all EKS clusters to find the correct one..."
          aws eks list-clusters --region $(awsRegion)
          CLUSTER_NAME=$(aws eks list-clusters --region $(awsRegion) --query 'clusters[0]' --output text)
          echo "Using first available cluster: $CLUSTER_NAME"
        fi
        
        if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" = "None" ]; then
          echo "Error: No EKS clusters found!"
          exit 1
        fi
        
        echo "Retrieved cluster name: $CLUSTER_NAME"
        echo "##vso[task.setvariable variable=CLUSTER_NAME]$CLUSTER_NAME"
        
      displayName: 'Get Cluster Name from Terraform'
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(awsRegion)
        
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig with Dynamic Cluster Name'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(CLUSTER_NAME)'
        
    - task: Kubernetes@1
      displayName: 'Verify Kubernetes Connectivity'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'nodes'
        
    - task: AWSCLI@1
      displayName: 'Get ECR Login Token'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'get-login-password'
        awsArguments: '--region $(awsRegion)'
      
    - script: |
        # Create ECR registry secret using current kubeconfig context
        echo "Creating ECR registry secret..."
        TOKEN=$(aws ecr get-login-password --region $(awsRegion))
        
        # Use the kubeconfig context that was set up by the kubernetesServiceConnection
        kubectl create secret docker-registry ecr-registry-secret \
          --namespace=default \
          --docker-server=$(ecrRegistry) \
          --docker-username=AWS \
          --docker-password=$TOKEN \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo "ECR registry secret created successfully"
      displayName: 'Create ECR Registry Secret'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)
        
    - task: Kubernetes@1
      displayName: 'Patch Service Account with Image Pull Secret'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'patch'
        arguments: 'serviceaccount deploy-robot -p "{\"imagePullSecrets\": [{\"name\": \"ecr-registry-secret\"}]}" --type=merge'
        
    - script: |
        # Replace image tag in deployment manifest
        sed -i "s|#{DOCKER_IMAGE_TAG}#|$(ecrRegistry)/$(imageRepository):$(tag)|g" manifests/deployment.yaml
        echo "Updated deployment manifest with image: $(ecrRegistry)/$(imageRepository):$(tag)"
      displayName: 'Update deployment manifest with ECR image'
      
    - task: Kubernetes@1
      displayName: 'Apply Service Account for ECR'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/serviceaccount-ecr.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply ConfigMap'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/configmap.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Service'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/service.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Deployment'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/deployment.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Pod Disruption Budget'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/pdb.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Horizontal Pod Autoscaler'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/hpa.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Apply Ingress'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/ingress.yaml'
        arguments: '--validate=false'
        
    - task: Kubernetes@1
      displayName: 'Wait for Deployment Rollout'
      continueOnError: true
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'rollout'
        arguments: 'status deployment/flask-app-deployment --timeout=300s'
        
    - task: AWSShellScript@1
      displayName: 'Validate Deployment Rollout'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        scriptType: 'inline'
        inlineScript: |
          set -euo pipefail

          echo "Refreshing kubeconfig for cluster $(CLUSTER_NAME)"
          aws eks update-kubeconfig --name $(CLUSTER_NAME) --region $(awsRegion)

          echo "Validating deployment status..."
          READY=$(kubectl get deployment flask-app-deployment -n $(namespace) -o jsonpath='{.status.readyReplicas}')
          DESIRED=$(kubectl get deployment flask-app-deployment -n $(namespace) -o jsonpath='{.status.replicas}')

          if [ -z "$DESIRED" ]; then
            echo "Deployment not found or replicas not reported. Collecting diagnostics..."
            kubectl get deployment flask-app-deployment -n $(namespace) -o yaml || true
            exit 1
          fi

          if [ "$READY" != "$DESIRED" ] || [ -z "$READY" ]; then
            echo "Deployment not fully ready (ready=$READY desired=$DESIRED). Collecting diagnostics..."
            kubectl get pods -n $(namespace) -o wide
            kubectl describe deployment flask-app-deployment -n $(namespace)
            kubectl describe pods -n $(namespace) -l app=flask-app
            kubectl get events -n $(namespace) --sort-by='.lastTimestamp' | tail -n 50
            exit 1
          fi

          echo "Deployment successfully rolled out (ready=$READY)."
        
    - task: Kubernetes@1
      displayName: 'Get Application Status'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'pods,svc,ingress -l app=flask-app'
        
    - task: Kubernetes@1
      displayName: 'Get Ingress URL'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'ingress flask-app-ingress -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"'