# Azure DevOps Pipeline for Terraform EKS Infrastructure and Flask App Deployment
# This pipeline provisions EKS infrastructure using Terraform and deploys a Flask application

trigger:
- main

variables:
  # Build variables
  awsECRServiceConnection: 'aws-ecr-connection'
  imageRepository: 'flask-static-app'
  ecrRegistry: '112779685052.dkr.ecr.us-east-1.amazonaws.com' # Your actual ECR URI
  dockerfilePath: 'src/Dockerfile'
  tag: '$(Build.BuildId)'
  imagePullPolicy: 'Always'
  
  # Terraform variables
  terraformVersion: 'latest'
  awsServiceConnection: 'service_connect_aws_tf'
  awsRegion: 'us-east-1'
  
  # Kubernetes variables
  kubernetesServiceConnection: 'KubernetesServiceConnection'
  namespace: 'default'

stages:
- stage: Infrastructure
  displayName: 'Provision EKS Infrastructure'
  jobs:
  - job: TerraformDeploy
    displayName: 'Deploy EKS Cluster with Terraform'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
        
    - task: TerraformTask@5
      displayName: 'Terraform Init'
      inputs:
        provider: 'aws'
        command: 'init'
        backendServiceAWS: $(awsServiceConnection)
        backendAWSBucketName: 'tf-state-file-4-az-pipeline-eks'
        backendAWSKey: 'terraform.tfstate'
        
    - task: TerraformTask@5
      displayName: 'Terraform Plan'
      inputs:
        provider: 'aws'
        command: 'plan'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - task: TerraformTask@5
      displayName: 'Terraform Apply'
      inputs:
        provider: 'aws'
        command: 'apply'
        environmentServiceNameAWS: $(awsServiceConnection)
        
    - script: |
        # Get cluster name from Terraform output
        CLUSTER_NAME=$(terraform output -raw cluster_name)
        echo "##vso[task.setvariable variable=EKS_CLUSTER_NAME;isOutput=true]$CLUSTER_NAME"
        echo "EKS Cluster Name: $CLUSTER_NAME"
      displayName: 'Get Cluster Name from Terraform'
      name: getClusterName
        
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(getClusterName.EKS_CLUSTER_NAME)'

- stage: Build
  displayName: 'Build and Push Docker Image'
  dependsOn: Infrastructure
  condition: succeeded()
  jobs:
  - job: BuildImage
    displayName: 'Build Flask Application'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - task: AWSCLI@1
      displayName: 'Login to AWS ECR'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'get-login-password'
        awsArguments: '--region $(awsRegion) | docker login --username AWS --password-stdin $(ecrRegistry)'
        
    - task: Docker@2
      displayName: 'Build Flask Docker Image'
      inputs:
        command: 'build'
        repository: '$(ecrRegistry)/$(imageRepository)'
        dockerfile: $(dockerfilePath)
        buildContext: 'src'
        tags: |
          $(tag)
          latest
          
    - task: Docker@2
      displayName: 'Push to AWS ECR'
      inputs:
        command: 'push'
        repository: '$(ecrRegistry)/$(imageRepository)'
        tags: |
          $(tag)
          latest

- stage: Deploy
  displayName: 'Deploy to EKS'
  dependsOn: Build
  condition: succeeded()
  variables:
    EKS_CLUSTER_NAME: $[ stageDependencies.Infrastructure.TerraformDeploy.outputs['getClusterName.EKS_CLUSTER_NAME'] ]
  jobs:
  - job: DeployToEKS
    displayName: 'Deploy Flask App to EKS'
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      displayName: 'Checkout source code'
      
    - script: |
        echo "Using EKS Cluster Name: $(EKS_CLUSTER_NAME)"
      displayName: 'Debug - Show Cluster Name'
      
    - task: AWSCLI@1
      displayName: 'Update Kubeconfig for Deployment'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'eks'
        awsSubCommand: 'update-kubeconfig'
        awsArguments: '--name $(EKS_CLUSTER_NAME)'
        
    - task: AWSCLI@1
      displayName: 'Setup ECR Secret for Kubernetes'
      inputs:
        awsCredentials: 'aws_cli'
        regionName: $(awsRegion)
        awsCommand: 'ecr'
        awsSubCommand: 'get-login-password'
        awsArguments: '--region $(awsRegion)'
      env:
        AWS_ACCOUNT_ID: '112779685052' # Your actual AWS Account ID
        
    - script: |
        # Create ECR registry secret
        TOKEN=$(aws ecr get-login-password --region $(awsRegion))
        kubectl create secret docker-registry ecr-registry-secret \
          --namespace=default \
          --docker-server=$(ecrRegistry) \
          --docker-username=AWS \
          --docker-password=$TOKEN \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Update service account to use the secret
        kubectl patch serviceaccount deploy-robot \
          -p '{"imagePullSecrets": [{"name": "ecr-registry-secret"}]}' \
          --namespace=default || echo "Service account patch skipped"
      displayName: 'Create ECR Registry Secret'
      env:
        AWS_DEFAULT_REGION: $(awsRegion)
        
    - script: |
        # Replace image tag in deployment manifest
        sed -i "s|#{DOCKER_IMAGE_TAG}#|$(ecrRegistry)/$(imageRepository):$(tag)|g" manifests/deployment.yaml
        echo "Updated deployment manifest with image: $(ecrRegistry)/$(imageRepository):$(tag)"
      displayName: 'Update deployment manifest with ECR image'
      
    - task: Kubernetes@1
      displayName: 'Apply Service Account for ECR'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/serviceaccount-ecr.yaml'
        
    - task: Kubernetes@1
      displayName: 'Apply ConfigMap'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/configmap.yaml'
        
    - task: Kubernetes@1
      displayName: 'Apply Service'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/service.yaml'
        
    - task: Kubernetes@1
      displayName: 'Apply Deployment'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/deployment.yaml'
        
    - task: Kubernetes@1
      displayName: 'Apply Pod Disruption Budget'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/pdb.yaml'
        
    - task: Kubernetes@1
      displayName: 'Apply Horizontal Pod Autoscaler'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/hpa.yaml'
        
    - task: Kubernetes@1
      displayName: 'Apply Ingress'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'apply'
        useConfigurationFile: true
        configuration: 'manifests/ingress.yaml'
        
    - task: Kubernetes@1
      displayName: 'Wait for Deployment Rollout'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'rollout'
        arguments: 'status deployment/flask-app-deployment --timeout=300s'
        
    - task: Kubernetes@1
      displayName: 'Get Application Status'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'pods,svc,ingress -l app=flask-app'
        
    - task: Kubernetes@1
      displayName: 'Get Ingress URL'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: $(kubernetesServiceConnection)
        namespace: $(namespace)
        command: 'get'
        arguments: 'ingress flask-app-ingress -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"'